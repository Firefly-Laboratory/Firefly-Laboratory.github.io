{"componentChunkName":"component---src-templates-blog-post-js","path":"/articles/before-you-memo/","result":{"data":{"markdownRemark":{"html":"<p>有很多描写React性能优化的文章。一般而言，如果某些state更新缓慢的话，你需要：</p>\n<ol>\n<li>验证是否正在运行一个生产环境的构建。（开发环境构建会刻意地缓慢一些，极端情况下可能会慢一个数量级）</li>\n<li>验证是否将树中的状态放在了一个比实际所需更高的位置上。（例如，将输入框的state放到了集中的store里可能不是一个好主意）</li>\n<li>运行React开发者工具来检测是什么导致了二次渲染，以及在高开销的子树上包裹<code>memo()</code>。（以及在需要的地方使用<code>useMemo()</code>）</li>\n</ol>\n<p>最后一步是很烦人的，特别是对于介于两者之间的组件，理想情况下，编译器可以为您完成这一步。未来也许会。\n<strong>在这篇文章里，我想分享两种不同的技巧。</strong> 它们十分基础，这也正是为什么人们很少会意识到它们可以提升渲染性能。\n<strong>这些技巧和你已经知道的内容是互补的</strong> 它们并不会替代<code>memo</code> 或者 <code>useMemo</code>，但是先试一试它们还是不错的</p>\n<h2>一个（人工）减缓的组件</h2>\n<p>这里是一个具有严重渲染性能问题的组件</p>\n<pre><code class=\"language-jsx\">import { useState } from 'react';\n\nexport default function App() {\n  let [color, setColor] = useState('red');\n  return (\n    &#x3C;div>\n      &#x3C;input value={color} onChange={(e) => setColor(e.target.value)} />\n      &#x3C;p style={{ color }}>Hello, world!&#x3C;/p>\n      &#x3C;ExpensiveTree />\n    &#x3C;/div>\n  );\n}\n\nfunction ExpensiveTree() {\n  let now = performance.now();\n  while (performance.now() - now &#x3C; 100) {\n    // Artificial delay -- do nothing for 100ms\n  }\n  return &#x3C;p>I am a very slow component tree.&#x3C;/p>;\n}\n</code></pre>\n<p><em>(<a href=\"https://codesandbox.io/s/frosty-glade-m33km?file=/src/App.js:23-513\">在这里试试</a>)</em></p>\n<p>问题就是当<code>App</code>中的<code>color</code>变化时，我们会重新渲染一次被我们手动大幅延缓渲染的<code>&#x3C;ExpensiveTree /></code>组件。\n我可以直接在它<a href=\"https://codesandbox.io/s/amazing-shtern-61tu4?file=/src/App.js\">上面写个memo()</a>然后收工大吉，但是现在已经有很多这方面的文章了，所以我不会再花时间讲解如何使用memo()来优化。我只想展示\n两种不同的解决方案。</p>\n<h2>解法 1： 向下移动State</h2>\n<p>如果你仔细看一下渲染代码，你会注意到返回的树中只有一部分真正关心当前的<code>color</code>：</p>\n<pre><code class=\"language-jsx{2,5-6}\">export default function App() {\n  let [color, setColor] = useState('red');\n  return (\n    &#x3C;div>\n      &#x3C;input value={color} onChange={(e) => setColor(e.target.value)} />\n      &#x3C;p style={{ color }}>Hello, world!&#x3C;/p>\n      &#x3C;ExpensiveTree />\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p>所以让我们把这一部分提取到<code>Form</code>组件中然后将state移动到该组件里：</p>\n<pre><code class=\"language-jsx{4,11,14,15}\">export default function App() {\n  return (\n    &#x3C;>\n      &#x3C;Form />\n      &#x3C;ExpensiveTree />\n    &#x3C;/>\n  );\n}\n\nfunction Form() {\n  let [color, setColor] = useState('red');\n  return (\n    &#x3C;>\n      &#x3C;input value={color} onChange={(e) => setColor(e.target.value)} />\n      &#x3C;p style={{ color }}>Hello, world!&#x3C;/p>\n    &#x3C;/>\n  );\n}\n</code></pre>\n<p><em>(<a href=\"https://codesandbox.io/s/billowing-wood-1tq2u?file=/src/App.js:64-380\">在这里试试</a>)</em></p>\n<p>现在如果<code>color</code>变化了，只有<code>Form</code>会重新渲染。问题解决了。</p>\n<h2>解法 2：内容提升</h2>\n<p>当一部分state在高开销树的上层代码中使用时上述解法就无法奏效了。举个例子，如果我们将<code>color</code>放到父元素<code>div</code>中。</p>\n<pre><code class=\"language-jsx{2,4}\">export default function App() {\n  let [color, setColor] = useState('red');\n  return (\n    &#x3C;div style={{ color }}>\n      &#x3C;input value={color} onChange={(e) => setColor(e.target.value)} />\n      &#x3C;p>Hello, world!&#x3C;/p>\n      &#x3C;ExpensiveTree />\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p><em>(<a href=\"https://codesandbox.io/s/bold-dust-0jbg7?file=/src/App.js:58-313\">在这里试试</a>)</em></p>\n<p>现在看起来我们似乎没办法再将不使用<code>color</code>的部分提取到另一个组件中了，因为这部分代码会首先包含父组件的<code>div</code>，然后才包含\n<code>&#x3C;ExpensiveTree /></code>。这时候无法避免使用<code>memo</code>了，对吗？又或者，我们也有办法避免？</p>\n<p>在沙盒中玩玩吧，然后看看你是否可以解决。\n...</p>\n<p>...</p>\n<p>...</p>\n<p>答案显而易见：</p>\n<pre><code class=\"language-jsx{4,5,10,15}\">export default function App() {\n  return (\n    &#x3C;ColorPicker>\n      &#x3C;p>Hello, world!&#x3C;/p>\n      &#x3C;ExpensiveTree />\n    &#x3C;/ColorPicker>\n  );\n}\n\nfunction ColorPicker({ children }) {\n  let [color, setColor] = useState(\"red\");\n  return (\n    &#x3C;div style={{ color }}>\n      &#x3C;input value={color} onChange={(e) => setColor(e.target.value)} />\n      {children}\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p><em>(<a href=\"https://codesandbox.io/s/wonderful-banach-tyfr1?file=/src/App.js:58-423\">在这里试试</a>)</em></p>\n<p>我们将<code>App</code>组件分割为两个子组件。依赖<code>color</code>的代码就和<code>color</code> state变量一起放入<code>ColorPicker</code>组件里。\n不关心<code>color</code>的部分就依然放在<code>App</code>组件中，然后以JSX内容的形式传递给<code>ColorPicker</code>，也被称为<code>children</code>属性。\n当<code>color</code>变化时，<code>ColorPicker</code>会重新渲染。但是它仍然保存着上一次从<code>App</code>中拿到的相同的<code>children</code>属性，所以React并不会访问那棵子树。\n因此，<code>ExpensiveTree</code>不会重新渲染。</p>\n<h2>寓意是什么？</h2>\n<p>在你用<code>memo</code>或者<code>useMemo</code>做优化时，如果你可以从不变的部分里分割出变化的部分，那么这看起来可能是有意义的。\n关于这些方式有趣的部分是<strong>他们本身并不真的和性能有关</strong>. 使用children属性来拆分组件通常会使应用程序的数据流更容易追踪，并且可以减少贯穿树的props数量。在这种情况下提高性能是锦上添花，而不是最终目标。\n奇怪的是，这种模式在将来还会带来更多的性能好处。\n举个例子，当<a href=\"https://reactjs.org/blog/2020/12/21/data-fetching-with-react-server-components.html\">服务器组件</a> 稳定且可被采用时，我们的<code>ColorPicker</code>组件就可以从服务器上获取到它的<code>children</code>。\n整个<code>&#x3C;ExpensiveTree /></code>组件或其部分都可以在服务器上运行，即使是顶级的React状态更新也会在客户机上“跳过”这些部分。\n这是<code>memo</code>做不到的事情!但是，这两种方法是互补的。不要忽视state下移(和内容提升!)\n然后，如果这还不够，那就使用Profiler然后用memo来写吧。</p>\n<h2>我之前不是读过这个吗？</h2>\n<p><a href=\"https://kentcdodds.com/blog/optimize-react-re-renders\">大概是的吧</a></p>\n<p>这并不是一个新想法。这只是一个React组合模型的自然结果。它太简单了以至于得不到赏识，然而它值得更多的爱。</p>","frontmatter":{"title":"在你写memo()之前","date":"2021-02-23","tags":["Articles"],"author":"Dan Abramov"},"excerpt":"有很多描写React性能优化的文章。一般而言，如果某些state更新缓慢的话，你需要： 验证是否正在运行一个生产环境的构建。（开发环境构建会刻意地缓慢一些，极端情况下可能会慢一个数量级） 验证是否将树中的状态放在了一个比实际所需更高的位置上。（例如，将输入框的state…"}},"pageContext":{"slug":"/articles/before-you-memo/"}},"staticQueryHashes":["2437428486","3141118629"]}